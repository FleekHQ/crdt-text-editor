"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const chai_1 = require("chai");
const browser_or_node_1 = require("browser-or-node");
const threads_id_1 = require("@textile/threads-id");
const crypto_1 = require("@textile/crypto");
const hub_threads_client_1 = require("@textile/hub-threads-client");
const buckets_1 = require("@textile/buckets");
const context_1 = require("@textile/context");
const spec_util_1 = require("./spec.util");
// Settings for localhost development and testing
const addrApiurl = 'http://127.0.0.1:3007';
const addrGatewayUrl = 'http://127.0.0.1:8006';
const sessionSecret = 'hubsession';
describe('All apis...', () => {
    describe('Buckets and accounts', () => {
        context('a developer', () => {
            const ctx = new context_1.Context(addrApiurl);
            let dev;
            it('should sign-up, create an API key, and sign it for the requests', () => __awaiter(void 0, void 0, void 0, function* () {
                // @note This should be done using the cli
                const { user } = yield spec_util_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                if (user)
                    dev = user;
                // @note This should be done using the cli
                ctx.withSession(dev.session);
                const { keyInfo } = yield spec_util_1.createKey(ctx, 'KEY_TYPE_ACCOUNT');
                yield ctx.withAPIKey(keyInfo === null || keyInfo === void 0 ? void 0 : keyInfo.key).withKeyInfo(keyInfo);
                chai_1.expect(ctx.toJSON()).to.have.ownProperty('x-textile-api-sig');
            })).timeout(3000);
            it('should then create a db for the bucket', () => __awaiter(void 0, void 0, void 0, function* () {
                const db = new hub_threads_client_1.Client(ctx);
                const id = threads_id_1.ThreadID.fromRandom();
                yield db.newDB(id, 'my-buckets');
                chai_1.expect(ctx.toJSON()).to.have.ownProperty('x-textile-thread-name');
            }));
            it('should create a new bucket in the db and push to it', function () {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (browser_or_node_1.isBrowser)
                        return this.skip();
                    // Create a new bucket in the db
                    const buckets = new buckets_1.Buckets(ctx);
                    const buck = yield buckets.create('mybuck');
                    chai_1.expect((_a = buck.root) === null || _a === void 0 ? void 0 : _a.name).to.equal('mybuck');
                    // Finally, push a file to the bucket.
                    const pth = path_1.default.join(__dirname, '../../..', 'testdata');
                    const stream = fs_1.default.createReadStream(path_1.default.join(pth, 'file1.jpg'));
                    const rootKey = ((_b = buck.root) === null || _b === void 0 ? void 0 : _b.key) || '';
                    const { root } = yield buckets.pushPath(rootKey, 'dir1/file1.jpg', stream);
                    chai_1.expect(root).to.not.be.undefined;
                    // We should have a thread named "my-buckets"
                    const users = new hub_threads_client_1.Client(ctx);
                    const res = yield users.getThread('my-buckets');
                    chai_1.expect(res.id).to.deep.equal(ctx.toJSON()['x-textile-thread']);
                });
            });
        });
        context('a developer with a user', function () {
            this.timeout(5000);
            const ctx = new context_1.Context(addrApiurl);
            let dev;
            let users;
            it('should sign-up, create an API key, and a new user', function () {
                return __awaiter(this, void 0, void 0, function* () {
                    // @note This should be done using the cli
                    const { user } = yield spec_util_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                    if (user)
                        dev = user;
                    // @note This should be done using the cli
                    // This time they create a user key
                    const { keyInfo } = yield spec_util_1.createKey(ctx.withSession(dev.session), 'KEY_TYPE_USER');
                    // This should automatically generate a user identity and validate keys, though we use a random ident
                    // for demo purposes here to show that it can also use custom identities
                    const identity = yield crypto_1.PrivateKey.fromRandom();
                    // We also explicitly specify a custom context here, which could be omitted as it uses reasonable defaults
                    const userContext = yield new context_1.Context(addrApiurl).withKeyInfo(keyInfo);
                    // In the app, we simply create a new user from the provided user key, signing is done automatically
                    users = new hub_threads_client_1.Client(userContext);
                    yield users.getToken(identity);
                    chai_1.expect(users.context.toJSON()).to.have.ownProperty('x-textile-api-sig');
                });
            }).timeout(3000);
            it('should then create a db for the bucket', function () {
                return __awaiter(this, void 0, void 0, function* () {
                    // @todo https://github.com/textileio/js-threads/pull/263 should fix this...
                    yield users.newDB(threads_id_1.ThreadID.fromRandom(), 'my-buckets');
                    chai_1.expect(users.context.toJSON()).to.have.ownProperty('x-textile-thread-name');
                });
            });
            it('should create a new bucket in the db and push to it', function () {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (browser_or_node_1.isBrowser)
                        return this.skip();
                    // Create a new bucket in the db from the user context
                    const buckets = new buckets_1.Buckets(users.context);
                    const buck = yield buckets.create('mybuck');
                    chai_1.expect((_a = buck.root) === null || _a === void 0 ? void 0 : _a.name).to.equal('mybuck');
                    // Finally, push a file to the bucket.
                    const pth = path_1.default.join(__dirname, '../../..', 'testdata');
                    const stream = fs_1.default.createReadStream(path_1.default.join(pth, 'file1.jpg'));
                    const rootKey = ((_b = buck.root) === null || _b === void 0 ? void 0 : _b.key) || '';
                    const { root } = yield buckets.pushPath(rootKey, 'dir1/file1.jpg', stream);
                    chai_1.expect(root).to.not.be.undefined;
                    // Ensure context is set properly
                    chai_1.expect(users.context.toJSON()).to.have.ownProperty('x-textile-thread-name');
                    chai_1.expect(users.context.get('x-textile-thread-name')).to.equal('my-buckets');
                    // We should have a thread named "my-buckets"
                    const res = yield users.getThread('my-buckets');
                    chai_1.expect(res.id).to.deep.equal(users.context.toJSON()['x-textile-thread']);
                });
            });
        });
    });
});
//# sourceMappingURL=users.spec.js.map