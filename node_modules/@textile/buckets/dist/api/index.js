"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BucketsGrpcClient = exports.bucketsArchiveWatch = exports.bucketsArchiveInfo = exports.bucketsArchiveStatus = exports.bucketsArchive = exports.bucketsSetDefaultArchiveConfig = exports.bucketsDefaultArchiveConfig = exports.bucketsPullPathAccessRoles = exports.bucketsPushPathAccessRoles = exports.bucketsRemovePath = exports.bucketsRemove = exports.bucketsPullIpfsPath = exports.bucketsPullPath = exports.bucketsSetPath = exports.bucketsPushPathNode = exports.bucketsPushPath = exports.bucketsListIpfsPath = exports.bucketsListPath = exports.bucketsList = exports.bucketsLinks = exports.bucketsRoot = exports.bucketsCreate = exports.StatusCode = exports.PathAccessRole = exports.AbortError = void 0;
const grpc_web_1 = require("@improbable-eng/grpc-web");
const bucketsd_pb_1 = require("@textile/buckets-grpc/api/bucketsd/pb/bucketsd_pb");
const bucketsd_pb_service_1 = require("@textile/buckets-grpc/api/bucketsd/pb/bucketsd_pb_service");
const context_1 = require("@textile/context");
const grpc_transport_1 = require("@textile/grpc-transport");
const cids_1 = __importDefault(require("cids"));
const event_iterator_1 = require("event-iterator");
const loglevel_1 = __importDefault(require("loglevel"));
const normalize_1 = require("./normalize");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const block = require('it-block');
const logger = loglevel_1.default.getLogger('buckets-api');
exports.AbortError = new Error('aborted');
var PathAccessRole;
(function (PathAccessRole) {
    PathAccessRole[PathAccessRole["PATH_ACCESS_ROLE_UNSPECIFIED"] = 0] = "PATH_ACCESS_ROLE_UNSPECIFIED";
    PathAccessRole[PathAccessRole["PATH_ACCESS_ROLE_READER"] = 1] = "PATH_ACCESS_ROLE_READER";
    PathAccessRole[PathAccessRole["PATH_ACCESS_ROLE_WRITER"] = 2] = "PATH_ACCESS_ROLE_WRITER";
    PathAccessRole[PathAccessRole["PATH_ACCESS_ROLE_ADMIN"] = 3] = "PATH_ACCESS_ROLE_ADMIN";
})(PathAccessRole = exports.PathAccessRole || (exports.PathAccessRole = {}));
const fromProtoArchiveConfig = (protoConfig) => {
    const config = {
        addr: protoConfig.getAddr(),
        countryCodes: protoConfig.getCountryCodesList(),
        dealMinDuration: protoConfig.getDealMinDuration(),
        dealStartOffset: protoConfig.getDealStartOffset(),
        excludedMiners: protoConfig.getExcludedMinersList(),
        fastRetrieval: protoConfig.getFastRetrieval(),
        maxPrice: protoConfig.getMaxPrice(),
        repFactor: protoConfig.getRepFactor(),
        trustedMiners: protoConfig.getTrustedMinersList(),
    };
    const renew = protoConfig.getRenew();
    if (renew) {
        config.renew = {
            enabled: renew.getEnabled(),
            threshold: renew.getThreshold(),
        };
    }
    return config;
};
const toProtoArchiveConfig = (config) => {
    const protoConfig = new bucketsd_pb_1.ArchiveConfig();
    protoConfig.setAddr(config.addr);
    protoConfig.setCountryCodesList(config.countryCodes);
    protoConfig.setDealMinDuration(config.dealMinDuration);
    protoConfig.setDealStartOffset(config.dealStartOffset);
    protoConfig.setExcludedMinersList(config.excludedMiners);
    protoConfig.setFastRetrieval(config.fastRetrieval);
    protoConfig.setMaxPrice(config.maxPrice);
    protoConfig.setRepFactor(config.repFactor);
    protoConfig.setTrustedMinersList(config.trustedMiners);
    if (config.renew) {
        const renew = new bucketsd_pb_1.ArchiveRenew();
        renew.setEnabled(config.renew.enabled);
        renew.setThreshold(config.renew.threshold);
        protoConfig.setRenew(renew);
    }
    return protoConfig;
};
/**
 * Archive status codes
 */
var StatusCode;
(function (StatusCode) {
    StatusCode[StatusCode["STATUS_UNSPECIFIED"] = 0] = "STATUS_UNSPECIFIED";
    StatusCode[StatusCode["STATUS_EXECUTING"] = 1] = "STATUS_EXECUTING";
    StatusCode[StatusCode["STATUS_FAILED"] = 2] = "STATUS_FAILED";
    StatusCode[StatusCode["STATUS_DONE"] = 3] = "STATUS_DONE";
    StatusCode[StatusCode["STATUS_CANCELED"] = 4] = "STATUS_CANCELED";
})(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
const convertRootObject = (root) => {
    return {
        key: root.getKey(),
        name: root.getName(),
        path: root.getPath(),
        createdAt: root.getCreatedAt(),
        updatedAt: root.getUpdatedAt(),
        thread: root.getThread(),
    };
};
const convertRootObjectNullable = (root) => {
    if (!root)
        return;
    return convertRootObject(root);
};
const convertMetadata = (metadata) => {
    if (!metadata)
        return;
    const roles = metadata.getRolesMap();
    const typedRoles = new Map();
    roles.forEach((entry, key) => typedRoles.set(key, entry));
    const response = {
        updatedAt: metadata.getUpdatedAt(),
        roles: typedRoles,
    };
    return response;
};
const convertPathItem = (item) => {
    const list = item.getItemsList();
    return {
        cid: item.getCid(),
        name: item.getName(),
        path: item.getPath(),
        size: item.getSize(),
        isDir: item.getIsDir(),
        items: list ? list.map(convertPathItem) : [],
        count: item.getItemsCount(),
        metadata: convertMetadata(item.getMetadata()),
    };
};
const convertPathItemNullable = (item) => {
    if (!item)
        return;
    return convertPathItem(item);
};
/**
 * Creates a new bucket.
 * @public
 * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.
 * @param isPrivate encrypt the bucket contents (default `false`)
 * @param cid (optional) Bootstrap the bucket with a UnixFS Cid from the IPFS network
 * @example
 * Creates a Bucket called "app-name-files"
 * ```typescript
 * import { Buckets } from '@textile/hub'
 *
 * const create = async (buckets: Buckets) => {
 *     return buckets.create("app-name-files")
 * }
 * ```
 *
 * @internal
 */
function bucketsCreate(api, name, isPrivate = false, cid, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('create request');
        const req = new bucketsd_pb_1.CreateRequest();
        req.setName(name);
        if (cid) {
            req.setBootstrapCid(cid);
        }
        req.setPrivate(isPrivate);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.Create, req, ctx);
        const links = res.getLinks();
        return {
            seed: res.getSeed_asU8(),
            seedCid: res.getSeedCid(),
            root: convertRootObjectNullable(res.getRoot()),
            links: links ? links.toObject() : undefined,
        };
    });
}
exports.bucketsCreate = bucketsCreate;
/**
 * Returns the bucket root CID
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 *
 * @internal
 */
function bucketsRoot(api, key, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('root request');
        const req = new bucketsd_pb_1.RootRequest();
        req.setKey(key);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.Root, req, ctx);
        return convertRootObjectNullable(res.getRoot());
    });
}
exports.bucketsRoot = bucketsRoot;
/**
 * Returns a list of bucket links.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @example
 * Generate the HTTP, IPNS, and IPFS links for a Bucket
 * ```typescript
 * import { Buckets } from '@textile/hub'
 *
 * const getLinks = async (buckets: Buckets) => {
 *    const links = buckets.links(bucketKey)
 *    return links.ipfs
 * }
 *
 * const getIpfs = async (buckets: Buckets) => {
 *    const links = buckets.links(bucketKey)
 *    return links.ipfs
 * }
 * ```
 *
 * @internal
 */
function bucketsLinks(api, key, path, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('link request');
        const req = new bucketsd_pb_1.LinksRequest();
        req.setKey(key);
        req.setPath(path);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.Links, req, ctx);
        return res.toObject();
    });
}
exports.bucketsLinks = bucketsLinks;
/**
 * Returns a list of all bucket roots.
 * @example
 * Find an existing Bucket named "app-name-files"
 * ```typescript
 * import { Buckets } from '@textile/hub'
 *
 * const exists = async (buckets: Buckets) => {
 *     const roots = await buckets.list();
 *     return roots.find((bucket) => bucket.name ===  "app-name-files")
 * }
 * ```
 *
 * @internal
 */
function bucketsList(api, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('list request');
        const req = new bucketsd_pb_1.ListRequest();
        const res = yield api.unary(bucketsd_pb_service_1.APIService.List, req, ctx);
        const roots = res.getRootsList();
        const map = roots ? roots.map((m) => m).map((m) => convertRootObject(m)) : [];
        return map;
    });
}
exports.bucketsList = bucketsList;
/**
 * Returns information about a bucket path.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @param path A file/object (sub)-path within a bucket.
 *
 * @internal
 */
function bucketsListPath(api, key, path, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('list path request');
        const req = new bucketsd_pb_1.ListPathRequest();
        req.setKey(key);
        req.setPath(path);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.ListPath, req, ctx);
        return {
            item: convertPathItemNullable(res.getItem()),
            root: convertRootObjectNullable(res.getRoot()),
        };
    });
}
exports.bucketsListPath = bucketsListPath;
/**
 * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.
 * @param path UnixFS path
 *
 * @internal
 */
function bucketsListIpfsPath(api, path, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('list path request');
        const req = new bucketsd_pb_1.ListIpfsPathRequest();
        req.setPath(path);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.ListIpfsPath, req, ctx);
        return convertPathItemNullable(res.getItem());
    });
}
exports.bucketsListIpfsPath = bucketsListIpfsPath;
/**
 * Pushes a file to a bucket path.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @param path A file/object (sub)-path within a bucket.
 * @param input The input file/stream/object.
 * @param opts Options to control response stream.
 * @remarks
 * This will return the resolved path and the bucket's new root path.
 * @example
 * Push a file to the root of a bucket
 * ```typescript
 * import { Buckets } from '@textile/hub'
 *
 * const pushFile = async (content: string, bucketKey: string) => {
 *    const file = { path: '/index.html', content: Buffer.from(content) }
 *    return await buckets.pushPath(bucketKey!, 'index.html', file)
 * }
 * ```
 *
 * @internal
 */
function bucketsPushPath(api, key, path, input, opts, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var e_1, _a;
            var _b, _c, _d, _e;
            // Only process the first input if there are more than one
            const source = (yield normalize_1.normaliseInput(input).next()).value;
            const client = grpc_web_1.grpc.client(bucketsd_pb_service_1.APIService.PushPath, {
                host: api.serviceHost,
                transport: api.rpcOptions.transport,
                debug: api.rpcOptions.debug,
            });
            // Send a close event to the bucket api upon abort
            if ((opts === null || opts === void 0 ? void 0 : opts.signal) !== undefined) {
                opts.signal.addEventListener('abort', () => {
                    client.close();
                    return reject(exports.AbortError);
                });
            }
            client.onMessage((message) => {
                var _a, _b, _c, _d;
                // Let's just make sure we haven't aborted this outside this function
                if ((_a = opts === null || opts === void 0 ? void 0 : opts.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    client.close();
                    return reject(exports.AbortError);
                }
                if (message.hasEvent()) {
                    const event = (_b = message.getEvent()) === null || _b === void 0 ? void 0 : _b.toObject();
                    if (event === null || event === void 0 ? void 0 : event.path) {
                        // @todo: Is there an standard library/tool for this step in JS?
                        const pth = event.path.startsWith('/ipfs/') ? event.path.split('/ipfs/')[1] : event.path;
                        const cid = new cids_1.default(pth);
                        const res = {
                            path: {
                                path: `/ipfs/${cid.toString()}`,
                                cid: cid,
                                root: cid,
                                remainder: '',
                            },
                            root: (_d = (_c = event.root) === null || _c === void 0 ? void 0 : _c.path) !== null && _d !== void 0 ? _d : '',
                        };
                        return resolve(res);
                    }
                    else if (opts === null || opts === void 0 ? void 0 : opts.progress) {
                        opts.progress(event === null || event === void 0 ? void 0 : event.bytes);
                    }
                }
                else {
                    return reject(new Error('Invalid reply'));
                }
            });
            client.onEnd((code, msg) => {
                if (code !== grpc_web_1.grpc.Code.OK) {
                    const message = msg ? msg : code.toString();
                    return reject(new Error(message));
                }
                else {
                    return resolve();
                }
            });
            if (source) {
                const head = new bucketsd_pb_1.PushPathRequest.Header();
                head.setPath(source.path || path);
                head.setKey(key);
                // Setting root here ensures pushes will error if root is out of date
                let root = '';
                if (opts === null || opts === void 0 ? void 0 : opts.root) {
                    // If we explicitly received a root argument, use that
                    root = typeof opts.root === 'string' ? opts.root : opts.root.path;
                }
                else {
                    // Otherwise, make a call to list path to get the latest known root
                    const head = yield bucketsListPath(api, key, '', ctx);
                    root = (_c = (_b = head.root) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ''; // Shouldn't ever be undefined here
                }
                head.setRoot(root);
                const req = new bucketsd_pb_1.PushPathRequest();
                req.setHeader(head);
                const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
                // Let's just make sure we haven't aborted this outside this function
                if ((_d = opts === null || opts === void 0 ? void 0 : opts.signal) === null || _d === void 0 ? void 0 : _d.aborted) {
                    return reject(exports.AbortError);
                }
                client.start(metadata);
                client.send(req);
                if (source.content) {
                    const process = yield block({ size: 32768, noPad: true });
                    try {
                        for (var _f = __asyncValues(process(source.content)), _g; _g = yield _f.next(), !_g.done;) {
                            const chunk = _g.value;
                            // Let's just make sure we haven't aborted this outside this function
                            if ((_e = opts === null || opts === void 0 ? void 0 : opts.signal) === null || _e === void 0 ? void 0 : _e.aborted) {
                                client.close();
                                return reject(exports.AbortError);
                            }
                            const buf = chunk.slice();
                            const part = new bucketsd_pb_1.PushPathRequest();
                            part.setChunk(buf);
                            client.send(part);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_a = _f.return)) yield _a.call(_f);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                // We only need to finish send here if we actually started
                client.finishSend();
            }
        }));
    });
}
exports.bucketsPushPath = bucketsPushPath;
function bucketsPushPathNode(api, key, path, input, opts, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var e_2, _a;
            var _b, _c, _d;
            // Only process the first input if there are more than one
            const source = (yield normalize_1.normaliseInput(input).next()).value;
            if (!source) {
                return reject(exports.AbortError);
            }
            const clientjs = new bucketsd_pb_service_1.APIServiceClient(api.serviceHost, api.rpcOptions);
            const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
            const stream = clientjs.pushPath(metadata);
            if ((opts === null || opts === void 0 ? void 0 : opts.signal) !== undefined) {
                opts.signal.addEventListener('abort', () => {
                    stream.cancel();
                    return reject(exports.AbortError);
                });
            }
            stream.on('data', (message) => {
                var _a, _b, _c, _d;
                // Let's just make sure we haven't aborted this outside this function
                if ((_a = opts === null || opts === void 0 ? void 0 : opts.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    stream.cancel();
                    return reject(exports.AbortError);
                }
                if (message.hasEvent()) {
                    const event = (_b = message.getEvent()) === null || _b === void 0 ? void 0 : _b.toObject();
                    if (event === null || event === void 0 ? void 0 : event.path) {
                        // TODO: Is there an standard library/tool for this step in JS?
                        const pth = event.path.startsWith('/ipfs/') ? event.path.split('/ipfs/')[1] : event.path;
                        const cid = new cids_1.default(pth);
                        const res = {
                            path: {
                                path: `/ipfs/${cid === null || cid === void 0 ? void 0 : cid.toString()}`,
                                cid,
                                root: cid,
                                remainder: '',
                            },
                            root: (_d = (_c = event.root) === null || _c === void 0 ? void 0 : _c.path) !== null && _d !== void 0 ? _d : '',
                        };
                        return resolve(res);
                    }
                    else if (opts === null || opts === void 0 ? void 0 : opts.progress) {
                        opts.progress(event === null || event === void 0 ? void 0 : event.bytes);
                    }
                }
                else {
                    return reject(new Error('Invalid reply'));
                }
            });
            stream.on('end', (status) => {
                if (status && status.code !== grpc_web_1.grpc.Code.OK) {
                    return reject(new Error(status.details));
                }
                else {
                    return resolve();
                }
            });
            stream.on('status', (status) => {
                if (status && status.code !== grpc_web_1.grpc.Code.OK) {
                    return reject(new Error(status.details));
                }
                else {
                    return resolve();
                }
            });
            const head = new bucketsd_pb_1.PushPathRequest.Header();
            head.setPath(source.path || path);
            head.setKey(key);
            // Setting root here ensures pushes will error if root is out of date
            let root = '';
            if (opts === null || opts === void 0 ? void 0 : opts.root) {
                // If we explicitly received a root argument, use that
                root = typeof opts.root === 'string' ? opts.root : opts.root.path;
            }
            else {
                // Otherwise, make a call to list path to get the latest known root
                const head = yield bucketsListPath(api, key, '', ctx);
                root = (_c = (_b = head.root) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ''; // Shouldn't ever be undefined here
            }
            head.setRoot(root);
            const req = new bucketsd_pb_1.PushPathRequest();
            req.setHeader(head);
            stream.write(req);
            if (source.content) {
                const process = yield block({ size: 32768, noPad: true });
                try {
                    for (var _e = __asyncValues(process(source.content)), _f; _f = yield _e.next(), !_f.done;) {
                        const chunk = _f.value;
                        // Let's just make sure we haven't aborted this outside this function
                        if ((_d = opts === null || opts === void 0 ? void 0 : opts.signal) === null || _d === void 0 ? void 0 : _d.aborted) {
                            stream.cancel();
                            return reject(exports.AbortError);
                        }
                        const buf = chunk.slice();
                        const part = new bucketsd_pb_1.PushPathRequest();
                        part.setChunk(buf);
                        stream.write(part);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) yield _a.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            stream.end();
        }));
    });
}
exports.bucketsPushPathNode = bucketsPushPathNode;
/**
 * Pushes a file to a bucket path.
 * @internal
 */
function bucketsSetPath(api, key, path, cid, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new bucketsd_pb_1.SetPathRequest();
        request.setKey(key);
        request.setPath(path);
        request.setCid(cid);
        yield api.unary(bucketsd_pb_service_1.APIService.SetPath, request, ctx);
    });
}
exports.bucketsSetPath = bucketsSetPath;
/**
 * Pulls the bucket path, returning the bytes of the given file.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @param path A file/object (sub)-path within a bucket.
 * @param opts Options to control response stream. Currently only supports a progress function.
 *
 * @internal
 */
function bucketsPullPath(api, key, path, opts, ctx) {
    const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
    const request = new bucketsd_pb_1.PullPathRequest();
    request.setKey(key);
    request.setPath(path);
    let written = 0;
    const events = new event_iterator_1.EventIterator(({ push, stop, fail }) => {
        const resp = grpc_web_1.grpc.invoke(bucketsd_pb_service_1.APIService.PullPath, {
            host: api.serviceHost,
            transport: api.rpcOptions.transport,
            debug: api.rpcOptions.debug,
            request,
            metadata,
            onMessage: (res) => __awaiter(this, void 0, void 0, function* () {
                const chunk = res.getChunk_asU8();
                push(chunk);
                written += chunk.byteLength;
                if (opts === null || opts === void 0 ? void 0 : opts.progress) {
                    opts.progress(written);
                }
            }),
            onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {
                if (status !== grpc_web_1.grpc.Code.OK) {
                    fail(new Error(message));
                }
                stop();
            }),
        });
        return () => resp.close();
    });
    const it = Object.assign({ [Symbol.asyncIterator]() {
            return this;
        } }, events[Symbol.asyncIterator]());
    return it;
}
exports.bucketsPullPath = bucketsPullPath;
/**
 * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.
 * @param path A file/object (sub)-path within a bucket.
 * @param opts Options to control response stream. Currently only supports a progress function.
 *
 * @internal
 */
function bucketsPullIpfsPath(api, path, opts, ctx) {
    const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
    const request = new bucketsd_pb_1.PullIpfsPathRequest();
    request.setPath(path);
    let written = 0;
    const events = new event_iterator_1.EventIterator(({ push, stop, fail }) => {
        const resp = grpc_web_1.grpc.invoke(bucketsd_pb_service_1.APIService.PullIpfsPath, {
            host: api.serviceHost,
            transport: api.rpcOptions.transport,
            debug: api.rpcOptions.debug,
            request,
            metadata,
            onMessage: (res) => __awaiter(this, void 0, void 0, function* () {
                const chunk = res.getChunk_asU8();
                push(chunk);
                written += chunk.byteLength;
                if (opts === null || opts === void 0 ? void 0 : opts.progress) {
                    opts.progress(written);
                }
            }),
            onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {
                if (status !== grpc_web_1.grpc.Code.OK) {
                    fail(new Error(message));
                }
                stop();
            }),
        });
        return () => resp.close();
    });
    const it = Object.assign({ [Symbol.asyncIterator]() {
            return this;
        } }, events[Symbol.asyncIterator]());
    return it;
}
exports.bucketsPullIpfsPath = bucketsPullIpfsPath;
/**
 * Removes an entire bucket. Files and directories will be unpinned.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 *
 * @internal
 */
function bucketsRemove(api, key, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('remove request');
        const req = new bucketsd_pb_1.RemoveRequest();
        req.setKey(key);
        yield api.unary(bucketsd_pb_service_1.APIService.Remove, req, ctx);
        return;
    });
}
exports.bucketsRemove = bucketsRemove;
/**
 * Returns information about a bucket path.
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @param path A file/object (sub)-path within a bucket.
 * @param root optional to specify a root
 *
 * @internal
 */
function bucketsRemovePath(api, key, path, root, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('remove path request');
        const req = new bucketsd_pb_1.RemovePathRequest();
        req.setKey(key);
        req.setPath(path);
        if (root)
            req.setRoot(root);
        yield api.unary(bucketsd_pb_service_1.APIService.RemovePath, req, ctx);
        return;
    });
}
exports.bucketsRemovePath = bucketsRemovePath;
function bucketsPushPathAccessRoles(api, key, path, roles, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('remove path request');
        const req = new bucketsd_pb_1.PushPathAccessRolesRequest();
        req.setKey(key);
        req.setPath(path);
        roles.forEach((value, key) => req.getRolesMap().set(key, value));
        yield api.unary(bucketsd_pb_service_1.APIService.PushPathAccessRoles, req, ctx);
        return;
    });
}
exports.bucketsPushPathAccessRoles = bucketsPushPathAccessRoles;
function bucketsPullPathAccessRoles(api, key, path = '/', ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('remove path request');
        const req = new bucketsd_pb_1.PullPathAccessRolesRequest();
        req.setKey(key);
        req.setPath(path);
        const response = yield api.unary(bucketsd_pb_service_1.APIService.PullPathAccessRoles, req, ctx);
        const roles = response.getRolesMap();
        const typedRoles = new Map();
        roles.forEach((entry, key) => typedRoles.set(key, entry));
        return typedRoles;
    });
}
exports.bucketsPullPathAccessRoles = bucketsPullPathAccessRoles;
/**
 * @internal
 */
function bucketsDefaultArchiveConfig(api, key, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('default archive config request');
        const req = new bucketsd_pb_1.DefaultArchiveConfigRequest();
        req.setKey(key);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.DefaultArchiveConfig, req, ctx);
        const config = res.getArchiveConfig();
        if (!config) {
            throw new Error('no archive config returned');
        }
        return fromProtoArchiveConfig(config);
    });
}
exports.bucketsDefaultArchiveConfig = bucketsDefaultArchiveConfig;
/**
 * @internal
 */
function bucketsSetDefaultArchiveConfig(api, key, config, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('set default archive config request');
        const req = new bucketsd_pb_1.SetDefaultArchiveConfigRequest();
        req.setKey(key);
        req.setArchiveConfig(toProtoArchiveConfig(config));
        yield api.unary(bucketsd_pb_service_1.APIService.SetDefaultArchiveConfig, req, ctx);
        return;
    });
}
exports.bucketsSetDefaultArchiveConfig = bucketsSetDefaultArchiveConfig;
/**
 * archive creates a Filecoin bucket archive via Powergate.
 * @internal
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 * @param options Options that control the behavior of the bucket archive
 */
function bucketsArchive(api, key, options, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('archive request');
        const req = new bucketsd_pb_1.ArchiveRequest();
        req.setKey(key);
        if (options === null || options === void 0 ? void 0 : options.archiveConfig) {
            req.setArchiveConfig(toProtoArchiveConfig(options.archiveConfig));
        }
        yield api.unary(bucketsd_pb_service_1.APIService.Archive, req, ctx);
        return;
    });
}
exports.bucketsArchive = bucketsArchive;
/**
 * archiveStatus returns the status of a Filecoin bucket archive.
 * @internal
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 */
function bucketsArchiveStatus(api, key, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('archive status request');
        const req = new bucketsd_pb_1.ArchiveStatusRequest();
        req.setKey(key);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.ArchiveStatus, req, ctx);
        return {
            key: res.getKey(),
            status: res.getStatus(),
            failedMsg: res.getFailedMsg(),
        };
    });
}
exports.bucketsArchiveStatus = bucketsArchiveStatus;
/**
 * archiveInfo returns info about a Filecoin bucket archive.
 * @internal
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 */
function bucketsArchiveInfo(api, key, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('archive info request');
        const req = new bucketsd_pb_1.ArchiveInfoRequest();
        req.setKey(key);
        const res = yield api.unary(bucketsd_pb_service_1.APIService.ArchiveInfo, req, ctx);
        const archive = res.getArchive();
        const deals = archive ? archive.getDealsList() : [];
        return {
            key: res.getKey(),
            cid: archive ? archive.getCid() : undefined,
            deals: deals.map((d) => {
                return {
                    proposalCid: d.getProposalCid(),
                    miner: d.getMiner(),
                };
            }),
        };
    });
}
exports.bucketsArchiveInfo = bucketsArchiveInfo;
/**
 * archiveWatch watches status events from a Filecoin bucket archive.
 * @internal
 * @param key Unique (IPNS compatible) identifier key for a bucket.
 */
function bucketsArchiveWatch(api, key, callback, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('archive watch request');
        const req = new bucketsd_pb_1.ArchiveWatchRequest();
        req.setKey(key);
        const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
        const res = grpc_web_1.grpc.invoke(bucketsd_pb_service_1.APIService.ArchiveWatch, {
            host: api.context.host,
            request: req,
            metadata,
            onMessage: (rec) => {
                const response = {
                    id: rec.getJsPbMessageId(),
                    msg: rec.getMsg(),
                };
                callback(response);
            },
            onEnd: (status, message, _trailers) => {
                if (status !== grpc_web_1.grpc.Code.OK) {
                    return callback(undefined, new Error(message));
                }
                callback();
            },
        });
        return res.close.bind(res);
    });
}
exports.bucketsArchiveWatch = bucketsArchiveWatch;
/**
 * Raw API connected needed by Buckets CI code (compile friendly)
 * see more https://github.com/textileio/github-action-buckets
 */
class BucketsGrpcClient {
    /**
     * Creates a new gRPC client instance for accessing the Textile Buckets API.
     * @param context The context to use for interacting with the APIs. Can be modified later.
     */
    constructor(context = new context_1.Context(), debug = false) {
        this.context = context;
        this.serviceHost = context.host;
        this.rpcOptions = {
            transport: grpc_transport_1.WebsocketTransport(),
            debug,
        };
    }
    unary(methodDescriptor, req, ctx) {
        return new Promise((resolve, reject) => {
            const metadata = Object.assign(Object.assign({}, this.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());
            grpc_web_1.grpc.unary(methodDescriptor, {
                request: req,
                host: this.serviceHost,
                transport: this.rpcOptions.transport,
                debug: this.rpcOptions.debug,
                metadata,
                onEnd: (res) => {
                    const { status, statusMessage, message } = res;
                    if (status === grpc_web_1.grpc.Code.OK) {
                        if (message) {
                            resolve(message);
                        }
                        else {
                            resolve();
                        }
                    }
                    else {
                        reject(new Error(statusMessage));
                    }
                },
            });
        });
    }
}
exports.BucketsGrpcClient = BucketsGrpcClient;
//# sourceMappingURL=index.js.map