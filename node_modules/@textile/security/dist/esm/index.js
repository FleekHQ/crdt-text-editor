var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Common types/methods for Textile security including authentication and authorization.
 *
 * All methods here should be imported directly from the @textile/hub library.
 *
 * @packageDocumentation
 */
import { HMAC } from "fast-sha256";
import multibase from "multibase";
const encoder = new TextEncoder();
const decoder = new TextDecoder();
/**
 * createAPISig generates an authorization signature and message only.
 *
 * This function should NOT be used client-side, as it requires a key secret.
 * @public
 * @example
 * Basic usage
 * ```typescript
 * import {createAPISig, APISig} from '@textile/threads'
 *
 * async function sign (key: string) {
 *   const sig: APISig = await createAPISig(key)
 *   return sig
 * }
 * ```
 * @param {string} secret - The key secret to generate the signature. See KeyInfo for details.
 * @param {Date} date - An optional future Date to use as signature message. Once `date` has passed, this
 * authorization signature and message will expire. Defaults to one minute from `Date.now`.
 */
export function createAPISig(secret, date = new Date(Date.now() + 1000 * 60 * 30) // Default to 30 minutes
) {
    return __awaiter(this, void 0, void 0, function* () {
        const sec = multibase.decode(secret);
        const msg = date.toISOString();
        const hash = new HMAC(sec);
        const mac = hash.update(encoder.encode(msg)).digest();
        const sig = decoder.decode(multibase.encode("base32", mac));
        return { sig, msg };
    });
}
/**
 * Generate a UserAuth containing API key, signature, and message.
 *
 * The gRPC APIs will throw (or return an authorization error) if the message date has passed.
 * This function should NOT be used client-side, as it requires a key secret. The result does
 * not contain the secret and therefor CAN be used client side.
 * @public
 * @example
 * Create a new UserAuth
 * ```typescript
 * import {createUserAuth, KeyInfo, UserAuth} from '@textile/threads';
 *
 * async function auth (keyInfo: KeyInfo) {
 *   // Create an expiration and create a signature. 60s or less is recommended.
 *   const expiration = new Date(Date.now() + 60 * 1000)
 *   // Generate a new UserAuth
 *   const userAuth: UserAuth = await createUserAuth(keyInfo.key, keyInfo.secret ?? '', expiration)
 *   return userAuth
 * }
 * ```
 *
 * @param {string} key - The API key secret to generate the signature. See KeyInfo for details.
 * @param {string} secret - The API key secret to generate the signature. See KeyInfo for details.
 * @param {Date} date - An optional future Date to use as signature message. Default 1 minute from now.
 * @param {string} token - An optional user API token.
 */
export function createUserAuth(key, secret, date, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const partial = yield createAPISig(secret, date);
        return Object.assign(Object.assign({}, partial), { key,
            token });
    });
}
/**
 * expirationError is an error your app will receive anytime your credentials have expired.
 * @public
 */
export const expirationError = new Error("Auth expired. Consider calling withKeyInfo or withAPISig to refresh.");
export * from "./key";
//# sourceMappingURL=index.js.map